<div id="bpt-colorlife-container">
  <style>
    #bpt-colorlife-container {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 40px auto;
    }

    #bpt-colorlife-canvas {
      background: white;
      border: 1px solid #555;
      cursor: crosshair;
      touch-action: none;
    }

    #bpt-colorlife-controls button,
    #bpt-colorlife-controls input[type="color"] {
      padding: 6px 10px;
      margin: 4px;
      background: #111;
      color: #fff;
      border: 1px solid #ccc;
      cursor: pointer;
    }

    #bpt-colorlife-controls button:hover {
      background: #0f0;
      color: #000;
    }
  </style>

  <canvas id="bpt-colorlife-canvas" width="800" height="800"></canvas>
  <div id="bpt-colorlife-controls">
    <button onclick="ColorLife.toggle()">▶️ Start / ⏸️ Pause</button>
    <button onclick="ColorLife.clear()">🧹 Clear</button>
    <button onclick="ColorLife.reset()">🔁 Reset</button>
    <button onclick="ColorLife.zoomIn()">➕ Zoom In</button>
    <button onclick="ColorLife.zoomOut()">➖ Zoom Out</button>
    <button onclick="ColorLife.savePattern()">💾 Save</button>
    <button onclick="ColorLife.loadPattern()">📂 Load</button>
    <label>🎨 Color:
      <input type="color" id="colorPicker" value="#00ff00">
    </label>
  </div>

  <script>
    const ColorLife = (() => {
      const canvas = document.getElementById("bpt-colorlife-canvas");
      const ctx = canvas.getContext("2d");
      const colorPicker = document.getElementById("colorPicker");

      let cellSize = 10;
      let gridSize = 100;
      let running = false;
      let interval;
      let isDrawing = false;

      let grid = [];
      let initState = [];

      function createGrid() {
        return Array.from({ length: gridSize }, () =>
          Array.from({ length: gridSize }, () => ({ alive: 0, color: "#ffffff" }))
        );
      }

      function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            if (grid[x][y].alive) {
              ctx.fillStyle = grid[x][y].color;
              ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
            }
          }
        }
      }

      function hexToRGB(hex) {
        let bigint = parseInt(hex.slice(1), 16);
        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255
        };
      }

      function RGBToHex(r, g, b) {
        return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;
      }

      function avgColors(colors) {
        let r = 0, g = 0, b = 0;
        colors.forEach(hex => {
          const c = hexToRGB(hex);
          r += c.r;
          g += c.g;
          b += c.b;
        });
        const n = colors.length;
        return RGBToHex(Math.floor(r/n), Math.floor(g/n), Math.floor(b/n));
      }

      function countNeighbors(x, y) {
        let count = 0;
        let neighborColors = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            let nx = (x + dx + gridSize) % gridSize;
            let ny = (y + dy + gridSize) % gridSize;
            if (grid[nx][ny].alive) {
              count++;
              neighborColors.push(grid[nx][ny].color);
            }
          }
        }
        return { count, neighborColors };
      }

      function update() {
        const next = createGrid();
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const { count, neighborColors } = countNeighbors(x, y);
            const current = grid[x][y];

            if (current.alive) {
              next[x][y] = {
                alive: count === 2 || count === 3 ? 1 : 0,
                color: current.color
              };
            } else if (count === 3) {
              next[x][y] = {
                alive: 1,
                color: avgColors(neighborColors)
              };
            }
          }
        }
        grid = next;
        drawGrid();
      }

      function toggleCell(e) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
          let cell = grid[x][y];
          cell.alive = cell.alive ? 0 : 1;
          cell.color = cell.alive ? colorPicker.value : "#ffffff";
          drawGrid();
        }
      }

      function toggle() {
        if (running) clearInterval(interval);
        else interval = setInterval(update, 100);
        running = !running;
      }

      function clear() {
        grid = createGrid();
        drawGrid();
      }

      function reset() {
        grid = JSON.parse(JSON.stringify(initState));
        drawGrid();
      }

      function zoom(delta) {
        const newSize = cellSize + delta;
        if (newSize < 2 || newSize > 40) return;
        cellSize = newSize;
        drawGrid();
      }

      function savePattern() {
        localStorage.setItem("colorLifePattern", JSON.stringify(grid));
      }

      function loadPattern() {
        const saved = localStorage.getItem("colorLifePattern");
        if (saved) {
          grid = JSON.parse(saved);
          drawGrid();
        }
      }

      canvas.addEventListener("mousedown", e => { isDrawing = true; toggleCell(e); });
      canvas.addEventListener("mousemove", e => { if (isDrawing) toggleCell(e); });
      window.addEventListener("mouseup", () => isDrawing = false);
      canvas.addEventListener("mouseleave", () => isDrawing = false);

      // Init
      grid = createGrid();
      initState = JSON.parse(JSON.stringify(grid));
      drawGrid();

      return {
        toggle, clear, reset,
        zoomIn: () => zoom(2),
        zoomOut: () => zoom(-2),
        savePattern, loadPattern
      };
    })();
  </script>
</div>
